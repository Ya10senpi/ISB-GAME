<!DOCTYPE html>
<html lang="ja">
<head>
<meta charset="UTF-8">
<title>内閣総辞職ゲーム</title>
<style>
  body { text-align: center; background: #000; color: #fff; font-family: sans-serif; overflow:hidden; }
  canvas { background: #111; display: block; margin: 10px auto; }
  #hud { margin-top: 10px; }
  button { padding: 6px 14px; margin: 5px; }
  #gameover {
    position: absolute;
    top: 50%;
    left: 50%;
    transform: translate(-50%, -50%);
    font-size: 64px;
    font-weight: bold;
    display: none;
    text-shadow: 2px 2px 5px black;
    background: linear-gradient(270deg, red, orange, yellow, green, blue, indigo, violet);
    background-size: 1400% 1400%;
    -webkit-background-clip: text;
    -webkit-text-fill-color: transparent;
    animation: rainbow 3s linear infinite, flash 1s step-start infinite;
  }
  @keyframes rainbow {
    0% { background-position: 0% 50%; }
    100% { background-position: 100% 50%; }
  }
  @keyframes flash {
    50% { opacity: 0.2; }
    100% { opacity: 1; }
  }
</style>
</head>
<body>
  <h1>内閣総辞職ゲーム</h1>
  <canvas id="gameCanvas" width="640" height="640"></canvas>
  <div id="hud">
    <span id="score">Score: 0</span> | 
    <span id="highscore">High Score: 0</span> | 
    <span id="lives">支持率: 4</span>
    <div id="status"></div>
    <button id="startBtn">内閣発足</button>
    <button id="resetBtn">リセット</button>
  </div>
  <div id="gameover">内閣総辞職</div>
<script>
const canvas = document.getElementById('gameCanvas');
const ctx = canvas.getContext('2d');
const startBtn = document.getElementById('startBtn');
const resetBtn = document.getElementById('resetBtn');
const scoreEl = document.getElementById('score');
const highscoreEl = document.getElementById('highscore');
const livesEl = document.getElementById('lives');
const gameoverEl = document.getElementById('gameover');

document.addEventListener('keydown', e => {
  if(e.key === 'ArrowUp') player.dir={x:0,y:-1};
  if(e.key === 'ArrowDown') player.dir={x:0,y:1};
  if(e.key === 'ArrowLeft') player.dir={x:-1,y:0};
  if(e.key === 'ArrowRight') player.dir={x:1,y:0};
});

const tileSize = 32;
const gridSize = 20;

let player = { x: 1, y: 1, dir: {x:0,y:0}, frame:0 };
let enemies = [];
let pellets = [];
let score = 0;
let highscore = 0;
let lives = 4;
let gameRunning = false;

const playerImages = [new Image(), new Image()];
playerImages[0].src = 'image1.png';
playerImages[1].src = 'image2.png';

const enemyImg = new Image();
enemyImg.src = 'image3.png';
const pelletImg = new Image();
pelletImg.src = 'image4.png';

const maze = [
  [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1],
  [1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1],
  [1,0,1,1,1,1,0,1,1,1,1,1,0,1,1,1,1,0,0,1],
  [1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1],
  [1,0,1,1,1,1,0,1,1,1,1,1,0,1,1,1,1,0,0,1],
  [1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1],
  [1,0,1,1,1,1,0,1,1,1,1,1,0,1,1,1,1,0,0,1],
  [1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1],
  [1,0,1,1,1,1,0,1,1,1,1,1,0,1,1,1,1,0,0,1],
  [1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1],
  [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1]
];

function initGame(){
  player.x = 1; player.y = 1; player.dir={x:0,y:0}; score=0; lives=4; pellets=[];
  for(let y=0;y<maze.length;y++){
    for(let x=0;x<maze[y].length;x++){
      if(maze[y][x]===0) pellets.push({x,y});
    }
  }
  enemies=[{x:18,y:1},{x:18,y:9},{x:1,y:9},{x:10,y:5}];
  draw();
}

function draw(){
  ctx.clearRect(0,0,canvas.width,canvas.height);
  for(let y=0;y<maze.length;y++){
    for(let x=0;x<maze[y].length;x++){
      if(maze[y][x]===1){
        ctx.fillStyle='#333';
        ctx.fillRect(x*tileSize,y*tileSize,tileSize,tileSize);
      }
    }
  }
  pellets.forEach(p=>{
    ctx.drawImage(pelletImg,p.x*tileSize,p.y*tileSize,tileSize,tileSize);
  });
  ctx.save();
  ctx.translate(player.x*tileSize+tileSize/2, player.y*tileSize+tileSize/2);
  let angle = 0;
  if(player.dir.x===1) angle=0;
  if(player.dir.x===-1) angle=Math.PI;
  if(player.dir.y===1) angle=Math.PI/2;
  if(player.dir.y===-1) angle=-Math.PI/2;
  ctx.rotate(angle);
  ctx.drawImage(playerImages[player.frame],-tileSize/2,-tileSize/2,tileSize,tileSize);
  ctx.restore();
  enemies.forEach(e=>{
    ctx.drawImage(enemyImg,e.x*tileSize,e.y*tileSize,tileSize,tileSize);
  });
}

function movePlayer(){
  let nx=player.x+player.dir.x;
  let ny=player.y+player.dir.y;
  if(maze[ny] && maze[ny][nx]===0){
    player.x=nx; player.y=ny;
  }
  player.frame=(player.frame+1)%2;
}

function moveEnemies(){
  enemies.forEach(e=>{
    let dirOptions=[{x:1,y:0},{x:-1,y:0},{x:0,y:1},{x:0,y:-1}];
    let dirs=dirOptions.filter(d=> maze[e.y+d.y] && maze[e.y+d.y][e.x+d.x]===0);
    if(dirs.length>0){
      let chase=Math.random()<0.5;
      if(chase){
        dirs.sort((a,b)=> (Math.abs(e.x+a.x-player.x)+Math.abs(e.y+a.y-player.y)) - (Math.abs(e.x+b.x-player.x)+Math.abs(e.y+b.y-player.y)));
      }
      let d=dirs[0];
      e.x+=d.x; e.y+=d.y;
    }
  });
}

function checkCollisions(){
  for(let e of enemies){
    if(e.x===player.x && e.y===player.y){
      lives--;
      livesEl.textContent='支持率: '+lives;
      if(lives<=0){ endGame(false); return; }
      player.x=1; player.y=1;
    }
  }
  pellets=pellets.filter(p=>{
    if(p.x===player.x && p.y===player.y){
      score+=10;
      scoreEl.textContent='Score: '+score;
      return false;
    }
    return true;
  });
  if(pellets.length===0){ endGame(true); }
}

function gameLoop(){
  if(!gameRunning) return;
  movePlayer();
  moveEnemies();
  checkCollisions();
  draw();
}

function endGame(win){
  gameRunning=false;
  if(score>highscore){ highscore=score; highscoreEl.textContent='High Score: '+highscore; }
  gameoverEl.style.display='block';
}

startBtn.addEventListener('click',()=>{
  initGame();
  scoreEl.textContent='Score: '+score;
  livesEl.textContent='支持率: '+lives;
  gameoverEl.style.display='none';
  gameRunning=true;
});

resetBtn.addEventListener('click',()=>{
  initGame();
  scoreEl.textContent='Score: '+score;
  livesEl.textContent='支持率: '+lives;
  gameoverEl.style.display='none';
  gameRunning=true;
});

setInterval(gameLoop,300);
</script>
</body>
</html>